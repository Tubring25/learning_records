# 数组

## **[有效的数独](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2f9gg/)**

<aside>
💡 **思路**

1. 分别建立行、列、box数组，所有数据默认初始值为0
    例： `[[0,0,0,0.....],[0,0,0,0.....],....]`
2. 双层for循环，当前元素为 board[i][j]，判断当前行、列、box如能匹配到值，则重复
3. 当前box为 **j/3 + (i/3)*3**

</aside>

```jsx
var isValidSudoku = function(board) {
	// 创建行、列、box
  const row = new Array(9).fill(0).map(() => {
    return new Array(9).fill(0)
  })
  const col = new Array(9).fill(0).map(() => {
    return new Array(9).fill(0)
  })
  const box = new Array(9).fill(0).map(() => {
    return new Array(9).fill(0)
  })

  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 9; j++) {
			// 当前值
      if (board[i][j] === '.') continue
      const temp = parseInt(board[i][j])
      if (row[i][temp] === 1) return false
      if (col[j][temp] === 1) return false
      if (box[Math.floor(i / 3) * 3 + Math.floor(j / 3)][temp] === 1) return false

			// 如果没有则设置为1，后续再匹配如果为1则直接return false，证明重复
      row[i][temp] = 1
      col[j][temp] = 1
      box[Math.floor(i / 3) * 3 + Math.floor(j / 3)][temp] = 1
    }
  }
  return true
}
```

## [旋转图像](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhhkv/)

<aside>
💡 **思路**

</aside>

- **辅助数组**
    
    观察分析图像可知，对于 `N x N` 的数组而言，第`i`行第`j`个元素旋转后的位置为：第`j` 列第`i` 个元素。由此可得旋转后的位置为
    
    ![Untitled](%E6%95%B0%E7%BB%84%20183ea6f0960c4b468fcb7776a7cbf849/Untitled.png)
    
    ```jsx
    var rotate = function(matrix) {
        const n = matrix.length;
        const matrix_new = new Array(n).fill(0).map(() => new Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                matrix_new[j][n - i - 1] = matrix[i][j];
            }
        }
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                matrix[i][j] = matrix_new[i][j];
            }
        }
    };
    ```
    
- **对角线**
    
    先水平翻转，再对角线翻转
    
    ```jsx
    var rotate = function(matrix) {
        const n = matrix.length
        for (let i = 0; i < Math.floor(n / 2); i++) {
            for (let j = 0; j < n; j++) {
               [ matrix[i][j], matrix[n - i - 1][j] ] = [matrix[n-i-1][j], matrix[i][j]]
            }
        }
        for(let i = 0; i < n;i++) {
            for(let j = 0;j<i; j++) {
                [matrix[i][j], matrix[j][i] ]= [matrix[j][i], matrix[i][j] ]
            }
        }
    };
    ```